//package kr.co.mz.tutorial.io;
//
//import java.io.*;
//
//public class FileCopier {// 6/20 신입 교육 튜토리얼.
//
//    public static void main(String[] args) {
//        //먼저 널값인지 확인한다.
//        if (args.length > 2) {
//            System.out.println("");
//        }
//
//        String sourceFile = args[0];
//        String targetDirectory = args[1];
//        //이렇게 실행하면 예외 발생함 . 여기서 예외를 읽을줄 알아야 한다.
//        //at : where 의 개념.  이는 스택의 개념. stack trace 한것. 스택의 발자국.
//        //what : arrayindexofboundsexception. 어떤 에러인지.
//        // at 의 갯수 = 스택의 갯수. at이 하나만 있으면 한개의 스택이 쌓였다는것.
//        // 0 번쨰 배열값이 없어서 발생한다. x
//        //배열이 있긴 있다. 배열은 만들어 질때 길이가 정해진다.
//        // 배열의 길이보다 긴 인덱스를 찾아오라해서 생긴것.
//        // 배열의 길이가 - 개인데 0번쨰를 가져오라고 한것. 그래서 예외가발생.
//        // 배열의 길이가 0 인데 한개의 요소를 가져오라고 한것.
//
//
//    }//main
////메소드 만들때 아규먼트가 전혀 없으니까 일단스태틱하고 나중에 뺴던가.
//    private static File copyTo(String sourceFile, String targetDirectory) { // 메소드는 객체의 동작. 파라미터는 그 목적, 대상. 이름을 지을때도 잘 해줘야한다.
//        //1. 스트링으로 받았으면 이게 제대로 된 정보인지 검증 해야한다. var 쓰라고 자바에서 추천함. var 써주자.
//            // 검증과정에서 파일이 없을경우, 자바에서는 예외를 던진다.(예외반환) 널값 반환은 옛날방식, c언어식.
//        // 소스파일의 검증여부는 exits 로 한다. 그 이때의 에러 핸들링은 filenotfound로 한다. checked 예외는 메소드 엾에 throws 로 예외던짐.
//        //2. 디렉토리 검증시 오류 발생할 경우 에도, 던져야하는데 그 예외는 없다. 이걸 사용자정의 예외로 한다.
//        // 예외의 이름짓기는 '뭐가 실패햇다' 라는걸 나타내면된다.
//        //  다음에 기능 추가할것 TODO: 파일명 같은게 있을 경우, 덮어씌우던지, 괄호열고 이름추가하던지.
//        //  파일 객체 생성시에는 +로 이름짓는게 아니다. 생성자에 부모경로받고 스트링받아서 파일명 지정해주는게 맞다.
//        //  이름추가하는것도 모든상황생각하려면 조건 많다.
//        //3. 파일이 이미 존재하는경우에 어떻게 예외를 던질 것인가도 만든다.
//
//        //이까지 3작업을 한 코드들이 input validation 이다. 어떤 메소드든 입력의 검증이 필요하다.
//
//        //이제 카피 로직 만든다.
//        //1. 스트림으로 파일을 읽어오자.
//        /*
//        java는 바이트단위로만 읽을 수 있다. 메모리의 가장 작은 주소 단위.
//        in out 개념은, App 입장에서 생각. disk에서 들어오기에 input stream.
//
//
//        */
//            // 읽어보자. 파일의 길이를 파일에 물어보면된다.
//        // 여기서 발생하는 오류는 OS가 disk를 관리하고있으니, 앱에서 관리할수없는 오류가 발생할수있다고 열러주는
//        // IOE를 던지는것.자바에서 만들ㅇ놓은것.
//        // 그리고 길이만큼 다 읽었다면, 다썻다고 close 해주는것. 이걸 요즘엔s t-w-r 로 처리해주는것. finally는 옛날방식
//        // 읽고 write로 디렉토리로 파일생성해줌.
//        // trw 로 쓰면 throw 한번만 해주면된다. 여기서도 사용자정의 메세지 사용.
//        // 자바 독 주석 남기기. 메소드 설명과, 파라미터 설명, 예외의 설명까지 적어준다.
//        // 뭘해야하고 요굿사항을 어떻게 처리했는지, 상대방에게 알려주기 위해 공부하는것.
//
//        //자바는 파일을 1byte씩 읽어온다. byte배열 안만들고도 읽어올수있다.
//        //반복횟수를 알면읽을 수 있다. file 객체에 물어보면된다.
//        // 반복회수를 알아서 그 1바이트씩 읽어오면, 느리다.
////-----------------------------------------------------
//        // 그래서 배열 쓰고 , (바구니) 그만큼씩 옮기는것.
//        // 크기는 보통 4kb 로 한다. 4096. 요즘은커져서 8kb로도 함
//        // 읽은 갯수 선언, 읽은 갯수는 스트림에게 읽어오라고 시키는거임.
//        //  write 버퍼를 쓸거에요. 0번쨰부터 읽은 갯수 까지.
//                    // 시간재는거까지함  전체 메소드 시간재는 로직
//        // 아방금 반복한것보다 월등히 빠른 속도로 실행된다. 버퍼드를 쓰는게 더 빠르니까 이제 버퍼드 인풋 스트림 쓰는거.
//
//        // app 은 파일을 읽어오는 개념으로 모든 곳과 소통한다.
//        // 뒤에 disk가 있든 network 가 있든 상관없고, 같은 로직으로 (i/o) 데이터를 받아온다.
//        // webMVC는 NIO로 쓴건아니다.webflux가 있다.
//        // 이렇게 만든 파일복사의 흐름은  읽었으면 쓰고까지가 한 사이클.
//        // while 문으로 반복한다는건 코드 실행하는 동안 블록한다는것.
//
//        // 오늘한걸 제대로 공부하면 자바의 IO개념을 잘 잡은것.
//        // 자바의 IO로써 데이터 읽어서 들어오는건 InputStream. app밖으로 가는건 OutputStream.
//        // 인풋스트림의 타입하이어라키 찾아보기. 진짜 많이 나온다. 다 알필요는 없다. 얘네는 특정한 매챋ㄹ을 위해 존재하는것이고
//        // 인풋스트림과 아웃풋스트림의 개념을 잡으면 저거는 다 변수, api들이 잘 처리해줄것.
//
//
//        // 이걸 알고 넘어가는게 네트워크 개념의 시작
//        var sourceFileStream = new FileInputStream(sourceFile);
//
//        File source = new File(sourceFile);
//        File targetDirectoryFile = new File(targetDirectory);
//        InputStream in = null;
//        OutputStream out = null;
//
//        try {
//            in = new FileInputStream(source);
//            out = new FileOutputStream(targetDirectoryFile);
//            int lndex;
//            byte[] b = new byne
//            if(){
//
//            }
//
//
//        } catch (IOException e) {
//
//        }
//
//    }//copyFile
//}
